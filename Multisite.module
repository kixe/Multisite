<?php

/**
 *
 * Multisite module for Processwire
 * Inspired by Multisite module by authors: Ryan, Antti Peisa, Avoine Oy, Philipp "Soma" Urlich
 *
 * complete rewrite of the original module
 *
 * @author Christoph Thelen aka @kixe 2017/03/25
 * @copyright 2017 Christoph Thelen
 * @license Licensed under MIT, see LICENSE.txt
 * @link https://processwire.com/talk/topic/...
 * @version 1.0.0
 * @since 1.0.0 init - 2017/05/09
 * @since 1.0.1 default rootpage, domain related access control for MultisitePageTree, fixed path bug
 *
 * Copyright (c) 2017 by Christoph Thelen
 * Licensed under MIT, see LICENSE.txt
 *
 * FEATURES
 * - multilanguage support
 * - domain related homepage and custom 404 is set by id
 * - no restriction about naming, even multilanguage
 * - path modification is done by hooks
 *
 * SETTINGS
 * in config.php
 * $config->MultisiteDomains = array(
 *		"example.com" => array( // domain name is used to map to root page allow subdomains
 *       	"root" => 1026, // page id of the root page
 *			"http404" => 27 // page id of custom 404 error page (optionally)
 *      ),
 * );
 *
 *
 * $config->httpHosts = array_unique(array_merge($config->httpHosts, array_keys($config->MultisiteDomains)));
 */

class Multisite extends WireData implements Module {

	public $domains = null; // settings array $config->MultisiteDomains
	public $domain = null; // $config->httpHost
	public $it = false; // sanitized $_GET['it'] if set

	public $rootPage = null; // page instance of root page related to domain
	public $rootPageID = 1; // page id of root page related to domain
	public $rootPageName = ''; // language sensitive page name of root page related to domain

	public $languageSupport = false;

	public static function getModuleInfo() {
		return array(
			'title' => 'Multisite',
			'version' => 101,
			'summary' => 'Allows multiple sites with different domains run from single PW-site and database.',
			'href' => 'https://github.com/somatonic/Multisite',
			'singular' => true,
			'autoload' => true
			);
	}

	public function __construct() {
		// read config settings
		if(!empty(wire("config")->MultisiteDomains)) $this->domains = wire("config")->MultisiteDomains;
		if (array_key_exists(wire('config')->httpHost, $this->domains)) {
			$this->domain = wire('config')->httpHost;
			if (!array_key_exists('root', $this->domains[$this->domain])) throw new WireException("\$config->MultisiteDomains[$this->domain]['root'] not set");
			$this->rootPageID = $this->domains[$this->domain]['root'];
			$this->addHookAfter('AdminRestrictBranch::getBranchRootParentId', function($e) {
				// ATTENTION: make hooked function protected and hookable first
				$e->return = $this->rootPageID;
			});		
		}
	}

	public function init() {
		// quick exit
		if(empty($this->domains) || $this->domain == null) return;

		// settings ok?
		$this->configCheck($this->domain);

		// set custom http 404 page
		if (isset($this->domains[$this->domain]['http404'])) wire("config")->http404PageID = (int) $this->domains[$this->domain]['http404'];

		// dirty $_GET['it']
		if (isset($_GET['it']) && false === $this->it = $this->wire('sanitizer')->path($_GET['it'])) return;

		$superRootURL = $this->wire('config')->urls->root; // could this be anything else than '/'?

		// if in admin exit
		if(strpos($superRootURL . $this->it, $this->wire('config')->urls->admin) === 0) return;

		// if it's an assets file exit
		if(strpos($superRootURL . $this->it, $this->wire('config')->urls->assets) === 0) return;

		// if it's form-builder exit
		if(strpos($superRootURL . $this->it, "/form-builder/") !== false) return;

		// if called from PW front-end editing exit
		if($this->wire("input")->post->action == "PageFrontEditSave") return;

		// language support?
		if (wire('modules')->isInstalled('LanguageSupportPageNames')) $this->languageSupport = true;

		// get root Page instance
		$this->rootPage = wire('pages')->get($this->rootPageID);

		// modify $_GET['it']
		$this->langSegment = '';
		if ($this->languageSupport && $this->it) {
			foreach ($this->wire('languages') as $language) {
				$lang = $language->id;
				$this->langSegment = wire('pages')->get(1)->get("name$lang|name").'/';
				if (strpos($this->it, $this->langSegment) === 0) {
					break;
				}
			}
		} else if (!$this->it) $this->langSegment = wire('pages')->get(1)->name.'/';
		$this->rootPageName = isset($language->id)? $this->rootPage->get("name$language->id|name") : $this->rootPage->name;

		$_GET['it'] = isset($_GET['it'])? $this->langSegment.$this->rootPageName."/". substr($this->it,strlen($this->langSegment)) : $this->langSegment.$this->rootPageName."/";
		$this->addHookBefore('Page::render', $this, 'hookPageRender');
	}

	 /**
	 * Disallow access of pages residing in a MultisitePageTree for other domains other than the corresponding root page
	 *
	 */
	public function ready() {
		$pageTreeIDs = wire('page')->parents()->each('id');
		$pageTreeIDs[] = wire('page')->id;
		$multisiteRootIDs = array_map(function($i) { return $i = $i['root']; }, $this->domains);
		$matches = array_intersect($multisiteRootIDs, $pageTreeIDs);
		if (empty($matches)) return;
		reset($matches);
		if (key($matches) == wire('config')->httpHost) return;
		$view = new ProcessPageView();	
		$view->pageNotFound(wire('page'), $this->it, true, 'access not allowed');
	}

	 /**
	 * Hook Page::render hooks Page::path and LanguageSupportPageNames::getPagePath
	 *
	 * @param  HookEvent $e
	 * @see hookPagePath()
	 * @todo make hookable LanguageSupportPageNames::getPagePath
	 */
	protected function hookPageRender(HookEvent $e) {
		if ($this->languageSupport) $this->wire()->addHookAfter('LanguageSupportPageNames::getPagePath', $this, 'hookPagePath');
		else $this->wire()->addHookAfter('Page::path', $this, 'hookPagePath');
	}

	/**
	 * Hook called from hookPageRender()
	 * modifies $page->url, $page->httpUrl, $page->path, $page->localPath() $page->localUrl(), $page->localHttpUrl()
	 * @param  HookEvent $e
	 * @see hookPageRender()
	 */
	protected function hookPagePath(HookEvent $e) {
		// call from LanguageSupportPageNames
		if (isset($e->arguments[1])) {
			$lid = $e->arguments[1]->id;
			$this->langSegment = wire('pages')->get(1)->get("name$lid|name").'/';
			$this->rootPageName = $this->rootPage->localName($lid);
		}

		if ($this->languageSupport
		&& wire('modules')->get('LanguageSupportPageNames')->useHomeSegment == 0
		&& wire('user')->language->isDefault()
		&& $e->object == $this->rootPage) {
			$e->return = '/';
		}
		else {
			if (strpos($e->return, $this->rootPageName) !== strlen($this->langSegment) + 1) return;
			$cut = strlen($this->langSegment) + strlen($this->rootPageName) + 2;
			$e->return = '/'.$this->langSegment.substr($e->return, $cut);
		}
	}
	
	/**
	 * check config settings
	 * @param  string $domain
	 * @throws Exception
	 */
	public function configCheck($domain) {
		$ids = array('root' => $this->domains[$domain]['root']);
		if (array_key_exists('http404', $this->domains[$domain])) $ids['http404'] = $this->domains[$domain]['http404'];
		foreach ($ids as $key => $id) {
			$page = wire('pages')->get($id);
			if ($page instanceof NullPage) throw new WireException(sprintf("The page with ID = %s doesn't exist. Check \$config->MultisiteDomains['$domain']['$key'].", $id));
		}
	}
}
